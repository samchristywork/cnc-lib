<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>G-code Generator</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            height: 100vh;
            background-color: #f0f0f0;
        }
        #left-panel {
            width: 50vw;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
            box-sizing: border-box;
        }
        canvas {
            border: 1px solid #333;
            background-color: white;
            max-width: 100%;
            max-height: 100%;
        }
        #right-panel {
            width: 50vw;
            display: flex;
            flex-direction: column;
            padding: 20px;
            box-sizing: border-box;
        }
        #top-section {
            margin-bottom: 20px;
        }
        #image-upload {
            display: none;
        }
        #controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-bottom: 20px;
        }
        .control-row {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .control-group {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        #controls label {
            font-weight: bold;
            font-size: 12px;
        }
        #controls input {
            padding: 3px;
            font-size: 12px;
            width: 60px;
        }
        #controls span {
            font-size: 12px;
        }
        #bottom-section {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        button {
            padding: 5px 10px;
            font-size: 12px;
            cursor: pointer;
        }
        textarea {
            flex: 1;
            font-family: monospace;
            font-size: 14px;
            padding: 10px;
            resize: none;
        }
    </style>
</head>
<body>
    <div id="left-panel">
        <canvas id="canvas"></canvas>
    </div>
    <div id="right-panel">
        <div id="top-section">
            <input type="file" id="image-upload" accept="image/*">
            <button id="upload-image-btn">Upload Image</button>
            <button id="reset-btn">Reset</button>
            <button id="undo-btn">Undo</button>
            <button id="start-spindle-btn">Start Spindle</button>
            <button id="linear-move-btn">Linear Move</button>
            <button id="arc-cw-btn">Arc CW</button>
            <button id="arc-ccw-btn">Arc CCW</button>
        </div>
        <div id="controls">
            <div class="control-row">
                <label>Position:</label>
                <input type="number" id="x-input" step="0.1" value="0" min="-25" max="25" placeholder="X">
                <input type="number" id="y-input" step="0.1" value="0" min="-25" max="25" placeholder="Y">
                <input type="number" id="z-input" step="0.1" value="0" min="-5" max="5" placeholder="Z">
                <span>mm</span>
            </div>

            <div class="control-row">
                <label>Speed:</label>
                <input type="number" id="speed-input" step="10" value="50">
                <span>mm/min</span>
            </div>

            <div class="control-row">
                <label>RPM:</label>
                <input type="number" id="rpm-input" step="100" value="10000">
                <span>rpm</span>
            </div>

            <div class="control-row">
                <label>Diameter:</label>
                <input type="number" id="diameter-input" step="0.1" value="0.5">
                <span>mm</span>
            </div>

            <div class="control-row">
                <label>Arc Center:</label>
                <input type="number" id="arc-center-x-input" step="0.1" value="0" placeholder="X">
                <input type="number" id="arc-center-y-input" step="0.1" value="0" placeholder="Y">
                <span>mm</span>
                <button id="set-arc-center-btn">Set Arc Center</button>
            </div>
        </div>
        <div id="bottom-section">
            <button id="copy-btn">Copy</button>
            <textarea id="gcode-output"></textarea>
            <button id="paste-coords-btn">Paste Coordinates</button>
            <textarea id="coords-input" placeholder="Paste coordinates here, e.g.:&#10;0, 0, 0&#10;5, 5, -1&#10;10, 0, -1"></textarea>
            <button id="save-btn">Save</button>
            <button id="load-btn">Load</button>
            <textarea id="json-output"></textarea>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        const CANVAS_SIZE_MM = 50;

        const drill = {
            x: 0,           // mm
            y: 0,           // mm
            z: 0,           // mm
            speed: 50,      // mm/min
            rpm: 10000,     // revolutions per minute
            diameter: 0.5   // mm
        };

        const imageTransform = {
            scale: 1,
            aspectRatioScaleX: 1,
            aspectRatioScaleY: 1,
            offsetX: 0,     // mm
            offsetY: 0,     // mm
            rotation: 0     // degrees
        };

        const instructions = [];

        let zoom = 1;
        let panX = 0;
        let panY = 0;
        let isPanning = false;
        let lastPanX = 0;
        let lastPanY = 0;

        function mmToPixels(mm) {
            return (mm / CANVAS_SIZE_MM) * canvas.width;
        }

        function applyTransform() {
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.translate(panX, panY);
            ctx.scale(zoom, zoom);
        }

        function screenToCanvas(screenX, screenY) {
            const rect = canvas.getBoundingClientRect();
            const canvasX = screenX - rect.left;
            const canvasY = screenY - rect.top;

            const x = (canvasX - panX) / zoom;
            const y = (canvasY - panY) / zoom;

            return { x, y };
        }

        function getDrillColor() {
            let r = 127;
            let g = 127;
            let b = 127;

            if (drill.z < 0) {
                const factor = Math.min(Math.abs(drill.z) / 5, 1);
                r = 127 + Math.round(128 * factor);
            } else if (drill.z > 0) {
                const factor = Math.min(drill.z / 5, 1);
                b = 127 + Math.round(128 * factor);
            }

            return `rgb(${r}, ${g}, ${b})`;
        }

        function drawDrill() {
            const x = mmToPixels(drill.x);
            const y = mmToPixels(drill.y);
            const radius = mmToPixels(drill.diameter) / 2;

            ctx.fillStyle = getDrillColor();
            ctx.beginPath();
            ctx.arc(x, y, radius, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawToolPath() {
            if (instructions.length === 0) return;

            const totalInstructions = instructions.length;

            for (let i = 0; i < instructions.length; i++) {
                const instruction = instructions[i];

                const progress = i / Math.max(1, totalInstructions - 1); // 0 to 1
                const red = Math.round(progress * 255);
                const blue = Math.round((1 - progress) * 255);
                const color = `rgb(${red}, 0, ${blue})`;

                if (instruction.type === 'linear_move') {
                    if (instruction.fromZ < 0 && instruction.toZ < 0) {
                        const fromX = mmToPixels(instruction.fromX);
                        const fromY = mmToPixels(instruction.fromY);
                        const toX = mmToPixels(instruction.toX);
                        const toY = mmToPixels(instruction.toY);
                        const lineWidth = mmToPixels(instruction.diameter);

                        ctx.strokeStyle = color;
                        ctx.lineWidth = lineWidth;
                        ctx.lineCap = 'round';
                        ctx.lineJoin = 'round';

                        ctx.beginPath();
                        ctx.moveTo(fromX, fromY);
                        ctx.lineTo(toX, toY);
                        ctx.stroke();
                    }
                } else if (instruction.type === 'arc_cw' || instruction.type === 'arc_ccw') {
                    if (instruction.fromZ < 0 && instruction.toZ < 0) {
                        const fromX = mmToPixels(instruction.fromX);
                        const fromY = mmToPixels(instruction.fromY);
                        const toX = mmToPixels(instruction.toX);
                        const toY = mmToPixels(instruction.toY);

                        const centerXmm = instruction.fromX + instruction.i;
                        const centerYmm = instruction.fromY + instruction.j;
                        const centerX = mmToPixels(centerXmm);
                        const centerY = mmToPixels(centerYmm);

                        const lineWidth = mmToPixels(instruction.diameter);

                        const radiusMm = Math.sqrt(instruction.i * instruction.i + instruction.j * instruction.j);
                        const radius = mmToPixels(radiusMm);

                        const startAngle = Math.atan2(fromY - centerY, fromX - centerX);
                        const endAngle = Math.atan2(toY - centerY, toX - centerX);

                        ctx.strokeStyle = color;
                        ctx.lineWidth = lineWidth;
                        ctx.lineCap = 'round';
                        ctx.lineJoin = 'round';

                        ctx.beginPath();
                        const counterClockwise = (instruction.type === 'arc_cw');
                        ctx.arc(centerX, centerY, radius, startAngle, endAngle, counterClockwise);
                        ctx.stroke();
                    }
                }
            }

            for (let i = 0; i < instructions.length; i++) {
                const instruction = instructions[i];

                if (instruction.type === 'linear_move') {
                    const fromX = mmToPixels(instruction.fromX);
                    const fromY = mmToPixels(instruction.fromY);
                    const toX = mmToPixels(instruction.toX);
                    const toY = mmToPixels(instruction.toY);

                    ctx.strokeStyle = 'green';
                    ctx.lineWidth = 1;
                    ctx.lineCap = 'round';
                    ctx.lineJoin = 'round';

                    ctx.beginPath();
                    ctx.moveTo(fromX, fromY);
                    ctx.lineTo(toX, toY);
                    ctx.stroke();
                } else if (instruction.type === 'arc_cw' || instruction.type === 'arc_ccw') {
                    const fromX = mmToPixels(instruction.fromX);
                    const fromY = mmToPixels(instruction.fromY);
                    const toX = mmToPixels(instruction.toX);
                    const toY = mmToPixels(instruction.toY);

                    const centerXmm = instruction.fromX + instruction.i;
                    const centerYmm = instruction.fromY + instruction.j;
                    const centerX = mmToPixels(centerXmm);
                    const centerY = mmToPixels(centerYmm);

                    const radiusMm = Math.sqrt(instruction.i * instruction.i + instruction.j * instruction.j);
                    const radius = mmToPixels(radiusMm);

                    const startAngle = Math.atan2(fromY - centerY, fromX - centerX);
                    const endAngle = Math.atan2(toY - centerY, toX - centerX);

                    ctx.strokeStyle = 'green';
                    ctx.lineWidth = 1;
                    ctx.lineCap = 'round';
                    ctx.lineJoin = 'round';

                    ctx.beginPath();
                    const counterClockwise = (instruction.type === 'arc_cw');
                    ctx.arc(centerX, centerY, radius, startAngle, endAngle, counterClockwise);
                    ctx.stroke();
                }
            }
        }

        function redraw() {
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            applyTransform();

            if (img.complete && img.src) {
                ctx.save();

                const offsetXPixels = mmToPixels(imageTransform.offsetX);
                const offsetYPixels = mmToPixels(imageTransform.offsetY);
                ctx.translate(offsetXPixels, offsetYPixels);

                ctx.rotate(imageTransform.rotation * Math.PI / 180);

                const offset = -CANVAS_SIZE_MM / 2;
                const offsetPixels = mmToPixels(offset);
                const size = canvas.width;

                const finalScaleX = imageTransform.scale * imageTransform.aspectRatioScaleX;
                const finalScaleY = imageTransform.scale * imageTransform.aspectRatioScaleY;
                const scaledWidth = size * finalScaleX;
                const scaledHeight = size * finalScaleY;
                const scaledOffsetX = offsetPixels * finalScaleX;
                const scaledOffsetY = offsetPixels * finalScaleY;

                ctx.drawImage(img, scaledOffsetX, scaledOffsetY, scaledWidth, scaledHeight);

                ctx.restore();
            }

            drawToolPath();

            drawDrill();
        }

        function resizeCanvas() {
            const size = Math.min(window.innerWidth * 0.5 - 40, window.innerHeight - 40);
            canvas.width = size;
            canvas.height = size;

            const offsetMm = 25;
            const offsetPixels = (offsetMm / CANVAS_SIZE_MM) * canvas.width;
            panX = offsetPixels;
            panY = offsetPixels;

            redraw();
        }

        const img = new Image();
        img.onload = function() {
            if (img.width && img.height) {
                const aspectRatio = img.width / img.height;
                if (aspectRatio > 1) {
                    imageTransform.aspectRatioScaleX = 1;
                    imageTransform.aspectRatioScaleY = 1 / aspectRatio;
                } else {
                    imageTransform.aspectRatioScaleX = aspectRatio;
                    imageTransform.aspectRatioScaleY = 1;
                }
            }
            redraw();
        };
        img.src = 'Coin.png';

        function loadImageFromFile(file) {
            if (file && file.type.startsWith('image/')) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    img.src = e.target.result;
                };
                reader.readAsDataURL(file);
            }
        }

        document.getElementById('upload-image-btn').addEventListener('click', () => {
            document.getElementById('image-upload').click();
        });

        document.getElementById('image-upload').addEventListener('change', (event) => {
            const file = event.target.files[0];
            loadImageFromFile(file);
        });

        document.addEventListener('paste', (event) => {
            const items = event.clipboardData.items;
            for (let i = 0; i < items.length; i++) {
                if (items[i].type.indexOf('image') !== -1) {
                    const file = items[i].getAsFile();
                    loadImageFromFile(file);
                    event.preventDefault();
                    break;
                }
            }
        });

        resizeCanvas();

        window.addEventListener('resize', resizeCanvas);

        let isDragging = false;

        function updateDrillFromMouse(event) {
            const {x, y} = screenToCanvas(event.clientX, event.clientY);

            const mmX = (x / canvas.width) * CANVAS_SIZE_MM;
            const mmY = (y / canvas.height) * CANVAS_SIZE_MM;

            drill.x = Math.max(-25, Math.min(25, mmX));
            drill.y = Math.max(-25, Math.min(25, mmY));

            xInput.value = drill.x.toFixed(1);
            yInput.value = drill.y.toFixed(1);

            redraw();
        }

        canvas.addEventListener('click', (event) => {
            updateDrillFromMouse(event);
        });

        canvas.addEventListener('mousedown', (event) => {
            if (event.button === 0) {
                isDragging = true;
                updateDrillFromMouse(event);
            } else if (event.button === 1 || event.button === 2) {
                event.preventDefault();
                isPanning = true;
                lastPanX = event.clientX;
                lastPanY = event.clientY;
            }
        });

        canvas.addEventListener('mousemove', (event) => {
            if (isDragging) {
                updateDrillFromMouse(event);
            } else if (isPanning) {
                const deltaX = event.clientX - lastPanX;
                const deltaY = event.clientY - lastPanY;
                panX += deltaX;
                panY += deltaY;
                lastPanX = event.clientX;
                lastPanY = event.clientY;
                redraw();
            }
        });

        canvas.addEventListener('mouseup', (event) => {
            if (event.button === 0) {
                isDragging = false;
            } else if (event.button === 1 || event.button === 2) {
                isPanning = false;
            }
        });

        canvas.addEventListener('mouseleave', () => {
            isDragging = false;
            isPanning = false;
        });

        canvas.addEventListener('contextmenu', (event) => {
            event.preventDefault();
        });

        canvas.addEventListener('wheel', (event) => {
            event.preventDefault();

            const {x, y} = screenToCanvas(event.clientX, event.clientY);

            const zoomFactor = event.deltaY > 0 ? 0.9 : 1.1;
            const newZoom = Math.max(0.1, Math.min(10, zoom * zoomFactor));

            const zoomRatio = newZoom / zoom;
            panX = event.clientX - (event.clientX - panX) * zoomRatio;
            panY = event.clientY - (event.clientY - panY) * zoomRatio;

            zoom = newZoom;
            redraw();
        });

        const xInput = document.getElementById('x-input');
        const yInput = document.getElementById('y-input');
        const zInput = document.getElementById('z-input');
        const speedInput = document.getElementById('speed-input');
        const rpmInput = document.getElementById('rpm-input');
        const diameterInput = document.getElementById('diameter-input');

        function updateDrillFromControls() {
            drill.x = Math.max(-25, Math.min(25, parseFloat(xInput.value) || 0));
            drill.y = Math.max(-25, Math.min(25, parseFloat(yInput.value) || 0));
            drill.z = Math.max(-5, Math.min(5, parseFloat(zInput.value) || 0));
            drill.speed = parseFloat(speedInput.value) || 0;
            drill.rpm = parseFloat(rpmInput.value) || 0;
            drill.diameter = parseFloat(diameterInput.value) || 0;

            xInput.value = drill.x;
            yInput.value = drill.y;
            zInput.value = drill.z;

            redraw();
        }

        xInput.addEventListener('input', updateDrillFromControls);
        yInput.addEventListener('input', updateDrillFromControls);
        zInput.addEventListener('input', updateDrillFromControls);
        speedInput.addEventListener('input', updateDrillFromControls);
        rpmInput.addEventListener('input', updateDrillFromControls);
        diameterInput.addEventListener('input', updateDrillFromControls);

        document.getElementById('reset-btn').addEventListener('click', () => {
            drill.x = 0;
            drill.y = 0;
            drill.z = 0;
            drill.speed = 50;
            drill.rpm = 10000;
            drill.diameter = 0.5;

            xInput.value = drill.x;
            yInput.value = drill.y;
            zInput.value = drill.z;
            speedInput.value = drill.speed;
            rpmInput.value = drill.rpm;
            diameterInput.value = drill.diameter;

            redraw();
        });

        document.getElementById('undo-btn').addEventListener('click', () => {
            if (instructions.length > 0) {
                instructions.pop();
                updateGcodeOutput();
                updateJsonOutput();
                redraw();
            }
        });

        document.getElementById('start-spindle-btn').addEventListener('click', () => {
            drill.rpm = 10000;
            rpmInput.value = drill.rpm;
        });

        document.getElementById('set-arc-center-btn').addEventListener('click', () => {
            const arcCenterXInput = document.getElementById('arc-center-x-input');
            const arcCenterYInput = document.getElementById('arc-center-y-input');
            arcCenterXInput.value = drill.x;
            arcCenterYInput.value = drill.y;
        });

        document.getElementById('copy-btn').addEventListener('click', () => {
            const textarea = document.getElementById('gcode-output');
            textarea.select();
            document.execCommand('copy');
        });

        document.getElementById('save-btn').addEventListener('click', () => {
            updateJsonOutput();
        });

        document.getElementById('load-btn').addEventListener('click', () => {
            try {
                const textarea = document.getElementById('json-output');
                const loadedInstructions = JSON.parse(textarea.value);

                instructions.length = 0;
                instructions.push(...loadedInstructions);

                updateGcodeOutput();
                updateJsonOutput();
                redraw();
            } catch (e) {
                alert('Error loading instructions: ' + e.message);
            }
        });

        function getLastPosition() {
            if (instructions.length === 0) {
                return { x: 0, y: 0, z: 0 };
            }
            const lastInstruction = instructions[instructions.length - 1];
            return {
                x: lastInstruction.toX,
                y: lastInstruction.toY,
                z: lastInstruction.toZ
            };
        }

        function generateGcode() {
            let gcode = '; G-code generated by G-code Generator\n';
            gcode += 'G21 ; Set units to millimeters\n';
            gcode += 'G90 ; Use absolute positioning\n';
            gcode += 'G92 X0 Y0 Z0 ; Set current position as origin\n\n';

            let currentRpm = 0;
            let spindleOn = false;

            for (const instruction of instructions) {
                if (instruction.rpm > 0 && !spindleOn) {
                    gcode += `M3 S${instruction.rpm.toFixed(0)} ; Start spindle\n`;
                    spindleOn = true;
                    currentRpm = instruction.rpm;
                } else if (instruction.rpm > 0 && instruction.rpm !== currentRpm) {
                    gcode += `S${instruction.rpm.toFixed(0)} ; Change spindle speed\n`;
                    currentRpm = instruction.rpm;
                } else if (instruction.rpm === 0 && spindleOn) {
                    gcode += 'M5 ; Stop spindle\n';
                    spindleOn = false;
                    currentRpm = 0;
                }

                if (instruction.type === 'linear_move') {
                    const isRapid = instruction.fromZ >= 0 && instruction.toZ >= 0;

                    if (isRapid) {
                        gcode += `G00 X${instruction.toX.toFixed(3)} Y${(-instruction.toY).toFixed(3)} Z${instruction.toZ.toFixed(3)}`;
                        gcode += ' ; Rapid move\n';
                    } else {
                        gcode += `G01 X${instruction.toX.toFixed(3)} Y${(-instruction.toY).toFixed(3)} Z${instruction.toZ.toFixed(3)}`;
                        if (instruction.speed > 0) {
                            gcode += ` F${instruction.speed.toFixed(0)}`;
                        }
                        gcode += ' ; Linear move\n';
                    }
                } else if (instruction.type === 'arc_cw') {
                    const isRapid = instruction.fromZ >= 0 && instruction.toZ >= 0;

                    if (isRapid) {
                        gcode += `G00 X${instruction.toX.toFixed(3)} Y${(-instruction.toY).toFixed(3)} Z${instruction.toZ.toFixed(3)}`;
                        gcode += ' ; Rapid move (arc above surface)\n';
                    } else {
                        gcode += `G02 X${instruction.toX.toFixed(3)} Y${(-instruction.toY).toFixed(3)} Z${instruction.toZ.toFixed(3)} I${instruction.i.toFixed(3)} J${(-instruction.j).toFixed(3)}`;
                        if (instruction.speed > 0) {
                            gcode += ` F${instruction.speed.toFixed(0)}`;
                        }
                        gcode += ' ; Arc clockwise\n';
                    }
                } else if (instruction.type === 'arc_ccw') {
                    const isRapid = instruction.fromZ >= 0 && instruction.toZ >= 0;

                    if (isRapid) {
                        gcode += `G00 X${instruction.toX.toFixed(3)} Y${(-instruction.toY).toFixed(3)} Z${instruction.toZ.toFixed(3)}`;
                        gcode += ' ; Rapid move (arc above surface)\n';
                    } else {
                        gcode += `G03 X${instruction.toX.toFixed(3)} Y${(-instruction.toY).toFixed(3)} Z${instruction.toZ.toFixed(3)} I${instruction.i.toFixed(3)} J${(-instruction.j).toFixed(3)}`;
                        if (instruction.speed > 0) {
                            gcode += ` F${instruction.speed.toFixed(0)}`;
                        }
                        gcode += ' ; Arc counter-clockwise\n';
                    }
                }
            }

            if (spindleOn) {
                gcode += 'M5 ; Stop spindle\n';
            }

            gcode += '\nM30 ; Program end\n';
            return gcode;
        }

        function updateGcodeOutput() {
            const textarea = document.getElementById('gcode-output');
            textarea.value = generateGcode();
        }

        function updateJsonOutput() {
            const textarea = document.getElementById('json-output');
            textarea.value = JSON.stringify(instructions, null, 2);
        }

        function addLinearMove() {
            const lastPos = getLastPosition();

            instructions.push({
                type: 'linear_move',
                fromX: lastPos.x,
                fromY: lastPos.y,
                fromZ: lastPos.z,
                toX: drill.x,
                toY: drill.y,
                toZ: drill.z,
                speed: drill.speed,
                rpm: drill.rpm,
                diameter: drill.diameter
            });

            updateGcodeOutput();

            updateJsonOutput();

            redraw();
        }

        document.getElementById('linear-move-btn').addEventListener('click', addLinearMove);

        document.addEventListener('keydown', (event) => {
            if (event.code === 'Space' && event.target.tagName !== 'INPUT' && event.target.tagName !== 'TEXTAREA') {
                event.preventDefault();
                addLinearMove();
            }
        });

        document.getElementById('arc-cw-btn').addEventListener('click', () => {
            const lastPos = getLastPosition();
            const arcCenterXInput = document.getElementById('arc-center-x-input');
            const arcCenterYInput = document.getElementById('arc-center-y-input');

            const arcCenterX = parseFloat(arcCenterXInput.value) || 25;
            const arcCenterY = parseFloat(arcCenterYInput.value) || 25;

            const i = arcCenterX - lastPos.x;
            const j = arcCenterY - lastPos.y;

            instructions.push({
                type: 'arc_cw',
                fromX: lastPos.x,
                fromY: lastPos.y,
                fromZ: lastPos.z,
                toX: drill.x,
                toY: drill.y,
                toZ: drill.z,
                i: i,
                j: j,
                speed: drill.speed,
                rpm: drill.rpm,
                diameter: drill.diameter
            });

            updateGcodeOutput();

            updateJsonOutput();

            redraw();
        });

        document.getElementById('arc-ccw-btn').addEventListener('click', () => {
            const lastPos = getLastPosition();
            const arcCenterXInput = document.getElementById('arc-center-x-input');
            const arcCenterYInput = document.getElementById('arc-center-y-input');

            const arcCenterX = parseFloat(arcCenterXInput.value) || 25;
            const arcCenterY = parseFloat(arcCenterYInput.value) || 25;

            const i = arcCenterX - lastPos.x;
            const j = arcCenterY - lastPos.y;

            instructions.push({
                type: 'arc_ccw',
                fromX: lastPos.x,
                fromY: lastPos.y,
                fromZ: lastPos.z,
                toX: drill.x,
                toY: drill.y,
                toZ: drill.z,
                i: i,
                j: j,
                speed: drill.speed,
                rpm: drill.rpm,
                diameter: drill.diameter
            });

            updateGcodeOutput();

            updateJsonOutput();

            redraw();
        });

        document.getElementById('paste-coords-btn').addEventListener('click', () => {
            const coordsInput = document.getElementById('coords-input');
            const text = coordsInput.value.trim();

            if (!text) {
                alert('Please paste coordinates first');
                return;
            }

            const lines = text.split('\n');
            let addedCount = 0;

            for (const line of lines) {
                const trimmedLine = line.trim();
                if (!trimmedLine) continue;

                // Parse line - support formats like "x, y, z" or "x y z"
                const parts = trimmedLine.split(/[,\s]+/).map(p => parseFloat(p.trim()));

                if (parts.length < 2 || parts.length > 3) {
                    alert(`Invalid coordinate format on line: "${line}"\nExpected 2 or 3 numbers (X, Y, Z)`);
                    return;
                }

                if (parts.some(isNaN)) {
                    alert(`Invalid numbers on line: "${line}"`);
                    return;
                }

                const x = parts[0];
                const y = parts[1];
                const z = parts.length === 3 ? parts[2] : drill.z;

                const lastPos = getLastPosition();

                instructions.push({
                    type: 'linear_move',
                    fromX: lastPos.x,
                    fromY: lastPos.y,
                    fromZ: lastPos.z,
                    toX: x,
                    toY: y,
                    toZ: z,
                    speed: drill.speed,
                    rpm: drill.rpm,
                    diameter: drill.diameter
                });

                drill.x = x;
                drill.y = y;
                drill.z = z;

                addedCount++;
            }

            if (addedCount > 0) {
                updateControls();
                updateGcodeOutput();
                updateJsonOutput();
                redraw();
                coordsInput.value = '';
                alert(`Added ${addedCount} linear move(s)`);
            }
        });
    </script>
</body>
</html>
